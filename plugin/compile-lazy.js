var yaml = Npm.require('js-yaml');
var _ = Npm.require('underscore');
var path = Npm.require('path');
var sourcemap = Npm.require('source-map');
var unipackage = Npm.require('./unipackage.js');
var release = Npm.require('./release.js');
var Fiber = Npm.require('fibers');
var crypto = Npm.require('crypto');

// We will load the minifiers package.  This is the same package
// which is used internally by the bundler to combine & minify
// css and js for use in Meteor applications.
var minifiers = unipackage.load({
  library: release.current.library,
  packages: ['minifiers']
}).minifiers;

var CssTools = minifiers.CssTools;

// Re-implementations of useful functions from the bundler for handling CSS
function mergeCss(css) {
  var originals = {};
  var cssAsts = _.map(css, function(options) {
    var filename = options.servePath.replace(/^\//, '');
    originals[filename] = options;

    var parseOptions = { source: filename, position: true };
    var ast = CssTools.parseCss(options.data, parseOptions);
    ast.filename = filename;

    return ast;
  });

  var warnCb = function(filename, msg) {
    console.warn(filename + ': warn: ' + msg);
  };

  // Woo cache!
  var astCache = CssTools.mergeCssAsts(cssAsts, warnCb);

  var stringifiedCss = CssTools.stringifyCss(astCache, { sourcemap: true });

  stringifiedCss.map.sourcesContent =
    _.map(stringifiedCss.map.sources, function(filename) {
      return originals[filename].data;
    });

  // Woo compose source maps
  var newMap = sourcemap.SourceMapGenerator.fromSourceMap(
    new sourcemap.SourceMapConsumer(stringifiedCss.map));

  _.each(originals, function(options, name) {
    if (! options.sourceMap)
      return;

    try {
      newMap.applySourceMap(
        new sourcemap.SourceMapConsumer(options.sourceMap), name);
    } catch (err) {/* no-op */}
  });

  return {
    sourceMap: JSON.stringify(newMap),
    data: stringifiedCss.code,
    ast: astCache
  };
};

function minifyCss(css) {
  var minifiedCss = '';

  if (css.ast) {
    return {data: CssTools.minifyCssAst(css.ast)};
  } else {
    return {data: CssTools.minifyCss(css.data)};
  }
}

// Strips the YAML front-matter from the file, and returns an object.
// This object has both a sourcemap (currently unused), and the
// parsed yaml data for the frontmatter.
function stripFrontMatter(data, pathForSourceMap) {
  var map = new sourcemap.SourceNode(null, null, null, "");
  var sourceLines = data.split('\n');
  var inFm = /^--- *\n/.test(data);
  var fmSrc = '';

  // Don't use the first line to end the frontmatter
  if (inFm)
    sourceLines = sourceLines.slice(1);

  _.each(sourceLines, function(line, linum) {
    if (inFm) {
      if (/^--- *$/.test(line))
        inFm = false;
      else
        fmSrc += "\n" + line;
    } else {
      map.add(new sourcemap.SourceNode(linum + 2, 0, pathForSourceMap, line + '\n'));
    }
  });

  var fm = yaml.safeLoad(fmSrc) || {};

  var ret = map.toStringWithSourceMap({ file: pathForSourceMap });
  ret.fm = fm;

  return ret;
}

// isBrowser is true, calculates the sha1 hash of the source, then
// returns a new path, with a cachebuster query attached to it.
function addCacheBuster(path, src, isBrowser) {
  if (! isBrowser)
    return path;

  var shasum = crypto.createHash('sha1');
  shasum.update(src);
  return path + '?' + shasum.digest('hex');
}

// This function will accept a single file and will return
// an object with css and js properties, each containing
// arrays of each css and js file generated by the file.
// The object will also have a fm property containing the
// file's frontmatter.
function handleFile(compileStep, handler) {
  var data = compileStep.read();
  var fmStripped = stripFrontMatter(data.toString('utf8'), compileStep.pathForSourceMap);

  var fm = fmStripped.fm;
  var code = new Buffer(fmStripped.code, 'utf8');

  var css = [];
  var js = [];

  // Create a new compileStep object to pass to the original handler
  var readOffset = 0;
  var cStep = _.defaults({
    inputSize: code.length,

    read: function(n) {
      if (n === undefined || readOffset + n > code.length)
        n = code.length - readOffset;

      var ret = code.slice(readOffset, readOffset + n);
      readOffset += n;
      return ret;
    },

    appendDocument: function(options) {
      console.warn('The lazy file ' +
                   compileStep.inputPath +
                   ' appends a document section.\n' +
                   'This will not occur lazily.');
      compileStep.appendDocument(options);
    },

    addStylesheet: function(options) {
      if (!compileStep.archMatches('browser'))
        throw new Error("Stylesheets can only be emitted to " +
                        "browser targets");
      if (typeof options.data !== 'string')
        throw new Error("'data' option to addStylesheet must be a string");

      css.push(options);
    },

    addJavaScript: function(options) {
      if (typeof options.data !== 'string')
        throw new Error("'data' option to addJavaScript must be a string");
      if (typeof options.sourcePath !== 'string')
        throw new Error("'sourcePath' option must be supplied to addJavaScript.  Consider passing inputPath.");
      if (options.bare && ! compileStep.archMatches('browser'))
        throw new Error("'bare' option may only be used for browser targets");

      js.push(options);
    }
  }, compileStep);

  // Call the original handler
  handler(cStep);

  return {
    fm: fm,
    js: js,
    css: css
  };
}

// Generates a handler for a lazy version of an extension.
// Will delegate compiling to the original extension, but also 
// handle making the extension lazy loaded.
function genHandler(extension, handler) {
  return function(compileStep) {
    var isBrowser = compileStep.archMatches('browser');
    var d = handleFile(compileStep, handler);

    var jsPaths = [];
    var cssPaths = [];

    if (d.fm.minify) {
      // If the frontmatter says to minify the source files, we want to merge all of them,
      // and produce a single file, which has also been passed through the minification
      // processes.
      if (d.css.length > 0) {
        var css = _.map(d.css, function(options) {
          options.servePath = path.join(compileStep.rootOutputPath, options.path);
          return options;
        });
        css = minifyCss(mergeCss(css));

        var assetPath = compileStep.inputPath + '.css';
        compileStep.addAsset({
          data: new Buffer(css.data, 'utf8'),
          path: assetPath
        });

        cssPaths = [
          addCacheBuster(assetPath, css.data, isBrowser)
        ];
      }

      if (d.js.length > 0) {
        var jsSrc = _.map(d.js, function(options) {
          return options.data;
        }).join('\n;\n');

        var assetPath = compileStep.inputPath + '.js';
        compileStep.addAsset({
          data: new Buffer(jsSrc, 'utf8'),
          path: assetPath
        });

        jsPaths = [
          addCacheBuster(assetPath, jsSrc, isBrowser)
        ];
      }
    } else {
      cssPaths = _.map(d.css, function(options) {
        if (options.sourceMap) {
          var sourceMapHash = crypto.createHash('sha1');
          sourceMapHash.update(options.sourceMap);
          var sourceMappingURL = path.join(
            path.dirname(options.path),
            sourceMapHash.digest('hex') + '.map'
          );

          compileStep.addAsset({
            data: new Buffer(options.sourceMap, 'utf8'),
            path: sourceMappingURL
          });

          options.data += '\n/*# sourceMappingURL=' + path.basename(sourceMappingURL) + ' */\n';
        }

        compileStep.addAsset({
          data: new Buffer(options.data, 'utf8'),
          path: options.path
        });

        return addCacheBuster(options.path, options.data, isBrowser);
      });

      jsPaths = _.map(d.js, function(options) {
        if (options.sourceMap) {
          var sourceMapHash = crypto.createHash('sha1');
          sourceMapHash.update(options.sourceMap);
          var sourceMappingURL = path.join(
            path.dirname(options.path),
            sourceMapHash.digest('hex') + '.map'
          );

          compileStep.addAsset({
            data: new Buffer(options.sourceMap, 'utf8'),
            path: sourceMappingURL
          });

          options.data += '\n//# sourceMappingURL=' + path.basename(sourceMappingURL) + '\n';
        }

        compileStep.addAsset({
          data: new Buffer(options.data, 'utf8'),
          path: options.path
        });

        return addCacheBuster(options.path, options.data, isBrowser);
      });
    }

    var clientOptions = {
      path: compileStep.inputPath,
      name: d.fm.name, 
      js: jsPaths,
      css: cssPaths
    };

    // Generate the client javascript for registering the file
    var clientJs = (
      "\n// (autogenerated) Register lazy file " + compileStep.inputPath + "\n" +
      "Package['lazy'].Lazy._register(" +
        JSON.stringify(clientOptions) +
        ", function(___) {eval(___)}" +
        (compileStep.archMatches('browser') ? "" : ", Assets") +
      ");"
    );

    // Register these files on the client
    compileStep.addJavaScript({
      path: compileStep.inputPath + ".register.js",
      sourcePath: compileStep.inputPath,
      data: clientJs
    });
  }
}

// Registers a handler for the lazy version of an extension
function registerExtension(extension, handler) {
  if (/^lazy\./.test(extension))
    return;

  console.log("registered: ", extension);

  Plugin.registerSourceHandler('lazy.' + extension, genHandler(extension, handler));
}

// Registers a handler for the lazy version of all extensions added by
// smart packages. This is done when this package is loaded, and will
// not correctly identify extensions added by smart packages after
// the lazy plugin has been loaded.
function registerSourceHandlers() {
  var library = release.current.library;

  var soft = library.softReloadCache;
  var loaded = library.loadedPackages;

  for (k in soft) {
    if (k === 'lazy')
      continue;

    // Make sure that the other plugin has initialized first
    soft[k].pkg._ensurePluginsInitialized();

    var sourceHandlers = soft[k].pkg.sourceHandlers;
    for (extension in sourceHandlers)
      registerExtension(extension, sourceHandlers[extension]);
  }

  for (k in loaded) {
    if (k === 'lazy')
      continue;

    // Make sure that the other plugin has initialized first
    loaded[k].pkg._ensurePluginsInitialized();

    var sourceHandlers = loaded[k].pkg.sourceHandlers;
    for (extension in sourceHandlers)
      registerExtension(extension, sourceHandlers[extension]);
  }
}

// Basic handler for javascript files. Js files aren't handled by any
// package (as handlers are written in javascript), so it has to be implemented
// seperately.
function jsRawHandler(compileStep) {
  compileStep.addJavaScript({
    data: compileStep.read().toString('utf8'),
    sourcePath: compileStep.inputPath,
    path: compileStep.inputPath
  });
}

// Register the extensions which will be supported by meteor-lazy
registerSourceHandlers();
registerExtension('js', jsRawHandler);

// Meteor Lazy will support lazy packages, which are lazily loaded bundles
// of code. It allows for multiple files to be combined together before
// they are lazily loaded.
Plugin.registerSourceHandler('lazypackage', function(compileStep) {
  var options = yaml.safeLoad(compileStep.read().toString('utf8'));
  var js = [];
  var css = [];

  _.each(options.files, function(file) {
    var cStep = {
    };
  });

  console.log(options);
  // TODO: Implement
  console.warn('Lazy packages have not been implemented yet');
});

